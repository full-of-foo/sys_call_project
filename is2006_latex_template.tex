\documentclass{article}
\usepackage{interspeech2006,amssymb,amsmath,epsfig}
\usepackage{hyperref} % For hyperlinks in the PDF

\usepackage{natbib} % Harvard style bib
\bibliographystyle{IEEEtranN}

\usepackage{lipsum} % Dummy text

\setcounter{page}{1}
\sloppy		% better line breaks
\ninept
%SM below a registered trademark definition
\def\reg{{\rm\ooalign{\hfil
     \raise.07ex\hbox{\scriptsize R}\hfil\crcr\mathhexbox20D}}}


\title{System Software: Adding System Calls to the Linux Kernel}

\makeatletter
\def\name#1{\gdef\@name{#1\\}}
\makeatother
\name{{\em Anthony Troy and Liam Allen}}

\address{School of Computing  \\
Dublin City University \\
Dublin 9, Ireland\\
{\small \tt\{anthony.troy3,liam.allen5\}@mail.dcu.ie}
}

% You should submit a brief report, maximum of 8 pages, describing how you implemented the call, details of the changes made to the system files. 
% A listing of the application program, and a C program example using it.


\begin{document}

\maketitle

\begin{abstract}
Linux is arguably the most extensible and powerful operating system in existence today. 
Now with supports for ARM, x86-64, Alpha, PowerPC, SPARC and other architectures, 
the kernel is running on everything from small consumer electronics to supercomputers.
Mainstream Linux distributions aim to serve the needs of the majority, providing
interoperability with most common hardware such as display, sound and wireless devices.
Nevertheless, the exact needs of a user are rarely met by one distribution.
Accordingly one can customise the kernel for their given environment.
These adjustments might simply involve the tweaking of kernel parameters or removing
unneeded modules. More intricate alternations include adding custom 
kernel patches and modules. 
This papers briefly reviews the 
fundamental mechanism which facilitates this
extensibility, the kernel system call interface. Subsequently, in conjunction 
with our accompanying source code, we contribute the implementation of two trivial Linux system
calls.
\end{abstract}

\section{Introduction}
Since being first developed in 1991 by Linus Torvalds, Linux has quickly 
the surpassed the hobbyist market to becoming widely adopted in 
production environments. It currently powers everything from ``cell 
phones and embedded devices to more than 90 percent of the world's top 
500 supercomputers" \citep{Love7}. Then studying at the University of Helsinki,
Torvalds was abashed by the state of the operating systems (OS) space. Dominant 
OSs at this time were either proprietary or inextensible Unix systems. 
Accordingly, Torvalds released an immature but full-fledged Unix that was extensible
by design and licence. It is important to note that the initial success of the project 
would not have been possible without this permissive open-source license. 
Not long thereafter, Linux quickly attracted interests of many and ``evolved into a collaborative 
project" \citep{Love}.
\par
Today Torvalds continues to be the principal author and maintainer of the kernel while 
being backed by a sparse group of contributors. These developers are primarily 
sponsored by corporations such as Red Hat, Intel, IBM, Texas Instruments, Google
and Samsung, though anyone can potentially contribute. Being licensed under the
``GNU General Public License (GPL) version 2.0", one can download the kernel source
code and modify it, however distributing any changes requires making the altered source 
code available \citep{Love}. 
\par
Notwithstanding its monolithic design, \citet{Kroah} asserts that the kernel is the 
most flexible OS in existence. More specifically, Linux can be characterised 
as a ``modern" monolithic kernel in that it provides a high-level interface over the hardware
but can also load executable modules at runtime. Before we explore the kernel's
system call application programming interface (API), it is important to take stock
of exactly what the kernel is responsible for in terms of the overall operating system.
\par 
Albeit an undesirable thing to do, it is indeed possible 
to run programs on a machine without a kernel. Nevertheless, the
presence of a kernel  of course ``simplifies the writing and use of other programs,
and increases the power and flexibility available to programmers" \citep{Kerrisk}.
Meaning, on a high-level, the kernel provides a layer of abstraction over a machine's 
resources. Among other things, this layer is responsible for the 
following:
\vspace{1.8mm}
\begin{itemize}
  \item \textbf{Process creation and termination.} Under Linux a process
  is a program in execution wherein the object code is loaded 
  into memory along with other resources such as ``open files and pending signals, internal kernel data, processor state, a memory address space with one or more memory mappings, one or more threads of execution, and a data section containing global variables".
   Upon creation, the kernel first ``forks" 
a copy of the parent task and then ``execs" the process by loading the new
executable into the address space Upon termination, the kernel frees any resources
held by the process and notifies the parent \citep{Love}.
 \item \textbf{Process scheduling.} The Linux kernel is preemptive and multitasking, meaning
 that the rules determining when given processes get ran and on what CPU is managed by
 a separate subsystem, the kernel scheduler.\ Information about each process is held in a
process descriptor in dynamic memory and the scheduler divides processor time 
between runnable scheduled processes \citep{Love7, Kerrisk}.
 \item \textbf{Memory management.} In terms of user-space, 
 physical memory is a limited resource which must be fairly and efficiently shared among
 processes. As Linux is a virtual memory OS, the kernel virtualises memory among processes. 
 Meaning each process conceptually ``has full access to the system's physical memory" 
 from within their own process address space \citep{Love}.
 \item \textbf{Filesystem interfacing.} Linux's Virtual Filesystem (VFS) is a kernel
 subsystem which provides filesystem-related interfaces to user-space programs. Importantly,
 ``all filesystems rely on the VFS to enable them not only to coexist, but also to interoperate"
  \citep{Love}. Hence, a single call to read a file from any filesystem on any device is made possible. 
 \newpage
 \item \textbf{Device interfacing.} Simplified through VFS, the
 kernel provides standardised APIs to interface with mounted compute devices. 
 The kernel's process scheduler also arbitrates the concurrent access of multiple
processes to each device.
\end{itemize}

\noindent Robert \citet{Love7}, a long-standing developer on the Google kernel team, 
stresses that no other OS has scaled so well while supporting so many 
hardware types and environments. These feats were made possible 
through the maintenance of a concise and fundamental interface 
from which processes interact with the system, the system call
API. The rest of this paper discusses this interface while 
contributing two example system call implementations
 

\section{System Calls} 
\subsection{Syscall Interface}
In addition to providing mechanisms to create and terminate processes, 
system calls (or syscalls) permit processes to interact with hardware 
and other OS resources. They essentially act as concise entry-points into the kernel. 
Consequently, it is important to note that, in contrast to normal user applications, 
the kernel lives in a privileged system state having a ``protected memory space and full 
access to the hardware". Whereas user-space hosts only user-defined applications that see a subset 
of the available system resources \citep{Love}. This 
bridging interface over privileged resources
is key in ensuring that processes do not misbehave, which
in turn provides a more stable system.
\par
In general applications never directly execute system calls, instead
standard C library functions are often used which in turn implement
the system call interface. For instance, the fopen() function extends upon 
the open() syscall whereby it opens the file pointed to by path string parameter and returns the
associated stream \citep{Kerrisk}. These abstractions over syscalls provide caller-friendly interfaces 
which serve to save developer time in both writing and debugging code. Other notable 
library functions implementing system calls include write(), printf(), malloc() and free().
\par
The number of calls available is architecture dependant, 
however typically more than 90 percent of syscalls are implemented by all architectures. 
Interestingly, notwithstanding its large code base, the Linux kernel only implements around 350 system 
calls as of version 3.0 \citep{Love7}. Each system call is represented by a unique number that 
cannot change. The kernel does not facilitate for the dynamic adding or removing of syscalls, in
turn syscall numbers cannot be recycled as this would break backward-compatibility. 
\par

\subsection{Syscall Invocation}
From the application perspective, a C library function implementing a 
syscall executes as transparently as any other function. On the surface 
fopen() terminates the same way strcpy() does. This is because syscalls
in Linux ``are faster than in many other operating systems" \citep{Love7}.
The kernel is quickly and transparently switching from user-mode to kernel-mode,
executing the call and returning back to user-mode. The implementation of
fopen() invokes a software interrupt to switch to kernel-space through 
incurring a special exception to be managed by the system call handler.   
\par
In Fig 1, we illustrate the high-level steps involved in invoking execve() 
under an x86-32 architecture. First, the programs invokes the library function
which involves preparing the function arguments for the kernel by placing them 
into registers on the stack. Following, the function stores the execve() system call
number in another register. Now prepared for the context switch, the function invokes
the software interrupt instruction (0x80) which prompts the system
call handler to transfer the register values onto the kernel stack. Subsequently, 
the execve() system call service routine is invoked wherein the parameter 
values are validated and the requested work is performed. Finally the 
kernel stack registers are restored and execution returns to the execve() library 
function with an integer flag to indicate the success or failure of the system call.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.462\textwidth]{img}
    \caption{Invoking a syscall (x86-32)}
    \label{fig:img}
\end{figure}


\section{Study: Adding a Syscall}

\citet{Love7} asserts that a new system call should be both purposeful and ephemeral in execution while also standing the test of time. 
Meaning that a new system call should not be multiplexing. It should have one purpose which is fulfilled efficiently and transparently 
in adherence with the Unix motto, ``provide mechanism, not policy". Accordingly, 
an overly precise interface may not fair well over time so it should be generalised where possible. 
\par
Adding a new Linux system call is relatively simply. Our accompanying source code demonstrates
how straight-forward this actually is. Nevertheless, it is important to note
that there are compelling reasons against adding 
a system call in practice, these are as follows: for most use-cases a syscall is overkill; 
after a syscall is released the interface cannot ever change;
and going forward each architecture needs to support the syscall.
\par 
We present the adding of two trivial x86-32 system calls, the first simply generates some
kernel logs and the second deals with kernel data structures. Our enclosed 
source code is in text snippets form representing the additions made to
the 3.3.8 kernel. These files are follows:
\begin{itemize}
  \item bootstrap.sh
  \item install.sh
  \item Makefile\_snippet.txt
  \item arch/x86/boot/syscalls/syscall\_32\_snippet.txt
  \item include/linux/syscall\_snippet.txt
  \item hello/hello.c
  \item datastructs/datastructs.c
\end{itemize}
  
\subsection{Basic: Say Hello World}
\lipsum[1]
The kernel source code should also never be placed in the /usr/src/linux/ direc- tory, as that is the location of the kernel that the system libraries were built against,notyournewcustomkernel.Donotdoanykerneldevelopmentunder the /usr/src/ directory tree at all, but only in a local user directory where nothing bad can happen to the system.
(Nutshell)

\subsection{Intermediate: Dealing with Kernel Data Structures}
\lipsum[1]


\section{Discussion}
\lipsum[1]

\section{Conclusions}
\lipsum[1]


\vspace{-7.5mm}
\renewcommand{\refname}{\section{References}}
\bibliography{is2006_latex_template}

\end{document}
