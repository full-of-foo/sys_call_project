\documentclass{article}
\usepackage{interspeech2006,amssymb,amsmath,epsfig}
\usepackage{hyperref} % For hyperlinks in the PDF

\usepackage{natbib} % Harvard style bib
\bibliographystyle{IEEEtranN}

\usepackage{lipsum} % Dummy text

\setcounter{page}{1}
\sloppy		% better line breaks
\ninept
%SM below a registered trademark definition
\def\reg{{\rm\ooalign{\hfil
     \raise.07ex\hbox{\scriptsize R}\hfil\crcr\mathhexbox20D}}}


\title{System Software: Adding System Calls to the Linux Kernel}

\makeatletter
\def\name#1{\gdef\@name{#1\\}}
\makeatother
\name{{\em Anthony Troy and Liam Allen}}

\address{School of Computing  \\
Dublin City University \\
Dublin 9, Ireland\\
{\small \tt\{anthony.troy3,liam.allen5\}@mail.dcu.ie}
}

% You should submit a brief report, maximum of 8 pages, describing how you implemented the call, details of the changes made to the system files. 
% A listing of the application program, and a C program example using it.


\begin{document}

\maketitle

\begin{abstract}
Linux is arguably the most extensible and powerful operating system in existence today. 
Now with supports for ARM, x86-64, Alpha, PowerPC, SPARC and other architectures, 
the kernel is running on everything from small consumer electronics to supercomputers.
Mainstream Linux distributions aim to serve the needs of the majority, providing
interoperability with most common hardware such as display, sound and wireless devices.
Nevertheless, the exact needs of a user are rarely met by one distribution.
Accordingly one can customise the kernel for their given environment.
These adjustments might simply involve the tweaking of kernel parameters or removing
unneeded modules. More intricate alternations include adding custom 
kernel patches and modules. 
This papers briefly reviews the 
fundamental mechanism which facilitates this
extensibility, the kernel system call interface. Subsequently, in conjunction 
with our accompanying source code, we contribute the implementation of two trivial Linux system
calls.
\end{abstract}

\section{Introduction}
Since being first developed in 1991 by Linus Torvalds, Linux has quickly 
the surpassed the hobbyist market to becoming widely adopted in 
production environments. It currently powers everything from ``cell 
phones and embedded devices to more than 90 percent of the world's top 
500 supercomputers" \citep{Love7}. Then studying at the University of Helsinki,
Torvalds was abashed by the state of the operating systems (OS) space. Dominant 
OSs at this time were either proprietary or inextensible Unix systems. 
Accordingly, Torvalds released an immature but full-fledged Unix that was extensible
by design and licence. It is important to note that the initial success of the project 
would not have been possible without this permissive open-source license. 
Not long thereafter, Linux quickly attracted interests of many and ``evolved into a collaborative 
project" \citep{Love}.
\par
Today Torvalds continues to be the principal author and maintainer of the kernel while 
being backed by a sparse group of contributors. These developers are primarily 
sponsored by corporations such as Red Hat, Intel, IBM, Texas Instruments, Google
and Samsung, though anyone can potentially contribute. Being licensed under the
``GNU General Public License (GPL) version 2.0", one can download the kernel source
code and modify it, however distributing any changes requires making the altered source 
code available \citep{Love}. 
\par
Notwithstanding its monolithic design, \citet{Kroah} asserts that the kernel is the 
most flexible OS in existence. More specifically, Linux can be characterised 
as a ``modern" monolithic kernel in that it provides a high-level interface over the hardware
but can also load executable modules at runtime. Before we explore the kernel's
system call application programming interface (API), it is important to take stock
of exactly what the kernel is responsible for in terms of the overall operating system.
\par 
Albeit an undesirable thing to do, it is indeed possible 
to run programs on a machine without a kernel. Nevertheless, the
presence of a kernel  of course ``simplifies the writing and use of other programs,
and increases the power and flexibility available to programmers" \citep{Kerrisk}.
Meaning, on a high-level, the kernel provides a layer of abstraction over a machine's 
resources. Among other things, this layer is responsible for the 
following:
\vspace{1.8mm}
\begin{itemize}
  \item \textbf{Process creation and termination.} Under Linux a process
  is a program in execution wherein the object code is loaded 
  into memory along with other resources such as ``open files and pending signals, internal kernel data, processor state, a memory address space with one or more memory mappings, one or more threads of execution, and a data section containing global variables".
   Upon creation, the kernel first ``forks" 
a copy of the parent task and then ``execs" the process by loading the new
executable into the address space Upon termination, the kernel frees any resources
held by the process and notifies the parent \citep{Love}.
 \item \textbf{Process scheduling.} The Linux kernel is preemptive and multitasking, meaning
 that the rules determining when given processes get ran and on what CPU is managed by
 a separate subsystem, the kernel scheduler.\ Information about each process is held in a
process descriptor in dynamic memory and the scheduler divides processor time 
between runnable scheduled processes \citep{Love7, Kerrisk}.
 \item \textbf{Memory management.} In terms of user-space, 
 physical memory is a limited resource which must be fairly and efficiently shared among
 processes. As Linux is a virtual memory OS, the kernel virtualises memory among processes. 
 Meaning each process conceptually ``has full access to the system's physical memory" 
 from within their own process address space \citep{Love}.
 \item \textbf{Filesystem interfacing.} Linux's Virtual Filesystem (VFS) is a kernel
 subsystem which provides filesystem-related interfaces to user-space programs. Importantly,
 ``all filesystems rely on the VFS to enable them not only to coexist, but also to interoperate"
  \citep{Love}. Hence, a single call to read a file from any filesystem on any device is made possible. 
 \newpage
 \item \textbf{Device interfacing.} Simplified through VFS, the
 kernel provides standardised APIs to interface with mounted compute devices. 
 The kernel's process scheduler also arbitrates the concurrent access of multiple
processes to each device.
\end{itemize}

\noindent Robert \citet{Love7}, a long-standing developer on the Google kernel team, 
stresses that no other OS has scaled so well while supporting so many 
hardware types and environments. These feats were made possible 
through the maintenance of a concise and fundamental interface 
from which processes interact with the system, the system call
API. The rest of this paper discusses this interface while 
contributing two example system call implementations.
 

\section{System Call Interface} 
In addition to providing mechanisms to create and terminate processes, system calls (or syscalls) permit processes to interact with hardware and other OS resources. 
They essentially act as concise entry-points into the kernel.
It is important to note that, in contrast to normal user applications, 
the kernel lives in a privileged system state having a ``protected memory space and full 
access to the hardware". Whereas user-space hosts only user-defined applications that see a subset 
of the available system resources \citep{Love}. This 
bridging interface over privileged resources
is key in ensuring that processes do not misbehave, which
in turn provides a more stable system.
\par
TODO -  examples of syscalls. what happens when you call one

\lipsum[1]


\section{Adding a System Call}
\lipsum[1]
\begin{itemize}
\item \lipsum[1]
\end{itemize}

\subsubsection{Todo - Some title}
\lipsum[1]
The kernel source code should also never be placed in the /usr/src/linux/ direc- tory, as that is the location of the kernel that the system libraries were built against,notyournewcustomkernel.Donotdoanykerneldevelopmentunder the /usr/src/ directory tree at all, but only in a local user directory where nothing bad can happen to the system.
(Nutshell)

\subsubsection{Todo - Another title}
\lipsum[1]


\section{Discussion}
\lipsum[1]

\section{Conclusions}
\lipsum[1]


\vspace{-7.5mm}
\renewcommand{\refname}{\section{References}}
\bibliography{is2006_latex_template}

\end{document}
